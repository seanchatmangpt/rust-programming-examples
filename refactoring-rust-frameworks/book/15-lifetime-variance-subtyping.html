<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter 15: Lifetime Variance &amp; Subtyping Advanced Semantics - Refactoring Rust Frameworks</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A comprehensive guide to refactoring Rust frameworks with real-world patterns and best practices">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-80709b90.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-a688046c.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Refactoring Rust Frameworks</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/seanchatmangpt/rust-programming-examples" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>
                        <a href="https://github.com/seanchatmangpt/rust-programming-examples/edit/main/docs/src/15-lifetime-variance-subtyping.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <span class=fa-svg id="git-edit-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M421.7 220.3l-11.3 11.3-22.6 22.6-205 205c-6.6 6.6-14.8 11.5-23.8 14.1L30.8 511c-8.4 2.5-17.5 .2-23.7-6.1S-1.5 489.7 1 481.2L38.7 353.1c2.6-9 7.5-17.2 14.1-23.8l205-205 22.6-22.6 11.3-11.3 33.9 33.9 62.1 62.1 33.9 33.9zM96 353.9l-9.3 9.3c-.9 .9-1.6 2.1-2 3.4l-25.3 86 86-25.3c1.3-.4 2.5-1.1 3.4-2l9.3-9.3H112c-8.8 0-16-7.2-16-16V353.9zM453.3 19.3l39.4 39.4c25 25 25 65.5 0 90.5l-14.5 14.5-22.6 22.6-11.3 11.3-33.9-33.9-62.1-62.1L314.3 67.7l11.3-11.3 22.6-22.6 14.5-14.5c25-25 65.5-25 90.5 0z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="lifetime-variance--subtyping-advanced-semantics"><a class="header" href="#lifetime-variance--subtyping-advanced-semantics">Lifetime Variance &amp; Subtyping Advanced Semantics</a></h1>
<h2 id="introduction-why-variance-matters"><a class="header" href="#introduction-why-variance-matters">Introduction: Why Variance Matters</a></h2>
<p>Variance is the cornerstone of Rust’s type system soundness. It determines when one type can be substituted for another, particularly around lifetimes and generic parameters. Misunderstanding variance leads to memory unsafety, use-after-free bugs, and API designs that compile but violate invariants. This chapter provides AI agents with a deep understanding of variance semantics to write sound Rust code.</p>
<p><strong>Core Principle</strong>: Variance rules exist to prevent you from storing short-lived references in long-lived containers, which would create dangling pointers.</p>
<hr>
<h2 id="1-variance-fundamentals"><a class="header" href="#1-variance-fundamentals">1. Variance Fundamentals</a></h2>
<h3 id="what-variance-means"><a class="header" href="#what-variance-means">What Variance Means</a></h3>
<p>Variance describes how subtyping relationships are preserved through type constructors. Given types <code>T</code> and <code>U</code> where <code>T</code> is a subtype of <code>U</code> (written <code>T &lt;: U</code>), variance determines whether <code>F&lt;T&gt; &lt;: F&lt;U&gt;</code> for some type constructor <code>F</code>.</p>
<p><strong>Three Variance Categories</strong>:</p>
<pre><code>Covariant:     F&lt;T&gt; &lt;: F&lt;U&gt;  when T &lt;: U  (subtyping preserved)
Contravariant: F&lt;U&gt; &lt;: F&lt;T&gt;  when T &lt;: U  (subtyping reversed)
Invariant:     No relationship between F&lt;T&gt; and F&lt;U&gt;
</code></pre>
<h3 id="lifetime-subtyping"><a class="header" href="#lifetime-subtyping">Lifetime Subtyping</a></h3>
<p>In Rust, <code>'a: 'b</code> means “<code>'a</code> outlives <code>'b</code>”, making <code>'a</code> a subtype of <code>'b</code>:</p>
<pre><code>'static: 'a  for any 'a (static lives forever)
'a: 'b       when 'a encompasses 'b (longer-lived)
</code></pre>
<p><strong>ASCII Diagram: Lifetime Relationships</strong></p>
<pre><code>'static ─────────────────────────────────────────────►
'a      ────────────────────────►
'b      ──────────►
'c      ───►

'static: 'a: 'b: 'c
(each is a subtype of lifetimes to its right)
</code></pre>
<h3 id="core-variance-rules"><a class="header" href="#core-variance-rules">Core Variance Rules</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&amp;'a T        // Covariant in both 'a and T
&amp;'a mut T    // Covariant in 'a, INVARIANT in T
*const T     // Covariant in T
*mut T       // INVARIANT in T
fn(T) -&gt; U   // Contravariant in T, covariant in U
Cell&lt;T&gt;      // INVARIANT in T
PhantomData&lt;T&gt;  // Covariant in T
PhantomData&lt;fn(T)&gt;  // Contravariant in T (function argument trick)
<span class="boring">}</span></code></pre>
<p><strong>Why Invariance Exists</strong>: Mutable references must be invariant to prevent soundness holes:</p>
<pre class="playground"><code class="language-rust">// Hypothetical unsound code if &amp;mut T were covariant in T
fn evil&lt;'a&gt;(input: &amp;mut &amp;'static str, shorter: &amp;'a str) {
    // If &amp;mut T were covariant, we could substitute:
    // &amp;mut &amp;'static str  ~&gt;  &amp;mut &amp;'a str
    *input = shorter; // UNSOUND: storing short-lived ref in long-lived slot
}

fn main() {
    let mut s: &amp;'static str = "static";
    {
        let temp = String::from("temporary");
        evil(&amp;mut s, &amp;temp);
        // temp dropped here
    }
    println!("{}", s); // USE-AFTER-FREE: s points to freed memory!
}</code></pre>
<p>The compiler rejects this because <code>&amp;mut T</code> is <strong>invariant</strong> in <code>T</code>.</p>
<h3 id="phantomdata-and-variance-declaration"><a class="header" href="#phantomdata-and-variance-declaration">PhantomData and Variance Declaration</a></h3>
<p><code>PhantomData&lt;T&gt;</code> allows you to declare variance for types that don’t directly use <code>T</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker::PhantomData;

struct Iter&lt;'a, T&gt; {
    ptr: *const T,
    end: *const T,
    _marker: PhantomData&lt;&amp;'a T&gt;, // Declares covariance in 'a and T
}
<span class="boring">}</span></code></pre>
<p><strong>Variance Table for PhantomData</strong>:</p>
<pre><code>PhantomData&lt;T&gt;         // Covariant in T
PhantomData&lt;&amp;T&gt;        // Covariant in T
PhantomData&lt;&amp;mut T&gt;    // Invariant in T
PhantomData&lt;*const T&gt;  // Covariant in T
PhantomData&lt;*mut T&gt;    // Invariant in T
PhantomData&lt;fn(T)&gt;     // Contravariant in T (function argument position)
PhantomData&lt;fn() -&gt; T&gt; // Covariant in T (return position)
PhantomData&lt;Cell&lt;T&gt;&gt;   // Invariant in T
</code></pre>
<h3 id="when-variance-violations-cause-soundness-bugs"><a class="header" href="#when-variance-violations-cause-soundness-bugs">When Variance Violations Cause Soundness Bugs</a></h3>
<p><strong>Pattern 1: Storing in Containers</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// UNSOUND if Vec&lt;T&gt; were invariant (it's covariant):
fn upcast_lifetime&lt;'a, 'b&gt;(v: Vec&lt;&amp;'a str&gt;) -&gt; Vec&lt;&amp;'b str&gt;
where
    'a: 'b,
{
    v // OK: Vec&lt;&amp;'a str&gt; &lt;: Vec&lt;&amp;'b str&gt; via covariance
}
<span class="boring">}</span></code></pre>
<p><strong>Pattern 2: Interior Mutability</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::Cell;

// Cell&lt;T&gt; is INVARIANT in T for safety:
fn cannot_upcast&lt;'a, 'b&gt;(c: Cell&lt;&amp;'a str&gt;) -&gt; Cell&lt;&amp;'b str&gt;
where
    'a: 'b,
{
    c // ERROR: cannot convert Cell&lt;&amp;'a str&gt; to Cell&lt;&amp;'b str&gt;
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="2-lifetime-variance-in-detail"><a class="header" href="#2-lifetime-variance-in-detail">2. Lifetime Variance in Detail</a></h2>
<h3 id="why-a-t-is-covariant-in-a"><a class="header" href="#why-a-t-is-covariant-in-a">Why &amp;’a T is Covariant in ’a</a></h3>
<p>Immutable references can safely shorten lifetimes:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn shorten&lt;'a, 'b&gt;(r: &amp;'a str) -&gt; &amp;'b str
where
    'a: 'b, // 'a outlives 'b
{
    r // OK: &amp;'a str &lt;: &amp;'b str (covariant)
}

let s = String::from("hello");
let r1: &amp;'static str = "world";
let r2: &amp;str = shorten(r1); // Shortens 'static to local lifetime
<span class="boring">}</span></code></pre>
<p><strong>ASCII Diagram: Lifetime Shortening</strong></p>
<pre><code>&amp;'a T                &amp;'b T
│                    │
├─────────►          ├────►
'a lifetime          'b lifetime

Covariance allows:  &amp;'a T  →  &amp;'b T  when 'a: 'b
</code></pre>
<h3 id="why-a-mut-t-is-invariant-in-a"><a class="header" href="#why-a-mut-t-is-invariant-in-a">Why &amp;’a mut T is Invariant in ’a</a></h3>
<p>Mutable references cannot safely change lifetimes:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// REJECTED: Cannot shorten mutable reference lifetime arbitrarily
fn broken_shorten&lt;'a, 'b&gt;(r: &amp;'a mut i32) -&gt; &amp;'b mut i32
where
    'a: 'b,
{
    r // ERROR: cannot infer appropriate lifetime
}
<span class="boring">}</span></code></pre>
<p><strong>Soundness Reason</strong>: If you could shorten, you could create aliasing:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Hypothetical unsound code:
fn create_alias&lt;'a&gt;(outer: &amp;'a mut i32) {
    let inner: &amp;mut i32 = outer; // Shortened lifetime
    // Now both outer and inner are live - ALIASING!
}
<span class="boring">}</span></code></pre>
<h3 id="practical-implications-for-api-design"><a class="header" href="#practical-implications-for-api-design">Practical Implications for API Design</a></h3>
<p><strong>Good API</strong>: Accept immutable references (covariant, flexible):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn log_message(msg: &amp;str) {
    println!("{}", msg);
}

// Can call with any lifetime:
log_message("static");
let temp = String::from("temporary");
log_message(&amp;temp);
<span class="boring">}</span></code></pre>
<p><strong>Restrictive API</strong>: Mutable references (invariant, inflexible):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn modify_message(msg: &amp;mut String) {
    msg.push_str("!");
}

// Lifetime must match exactly (no coercion):
let mut s = String::from("hello");
modify_message(&amp;mut s); // Exact match required
<span class="boring">}</span></code></pre>
<h3 id="variance-in-return-positions-vs-argument-positions"><a class="header" href="#variance-in-return-positions-vs-argument-positions">Variance in Return Positions vs Argument Positions</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Function types: fn(T) -&gt; U
// - Contravariant in T (arguments)
// - Covariant in U (return)

type Handler&lt;'a&gt; = fn(&amp;'a str) -&gt; &amp;'a str;

// Contravariant in argument: can pass function expecting longer lifetime
fn needs_short_lived(h: Handler&lt;'_&gt;) { /* ... */ }

fn handler_long(s: &amp;'static str) -&gt; &amp;'static str { s }
needs_short_lived(handler_long); // OK: contravariance

// Covariant in return: can return shorter lifetime
fn returns_handler&lt;'a&gt;() -&gt; Handler&lt;'a&gt; {
    handler_long // OK: covariance in return
}
<span class="boring">}</span></code></pre>
<h3 id="hrtbs-and-variance-interaction"><a class="header" href="#hrtbs-and-variance-interaction">HRTBs and Variance Interaction</a></h3>
<p>Higher-Ranked Trait Bounds (<code>for&lt;'a&gt;</code>) quantify over all possible lifetimes:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// HRTB: Works for ANY lifetime 'a
fn apply&lt;F&gt;(f: F, s: &amp;str) -&gt; &amp;str
where
    F: for&lt;'a&gt; Fn(&amp;'a str) -&gt; &amp;'a str,
{
    f(s)
}

// Non-HRTB: Works for SPECIFIC lifetime
fn apply_specific&lt;'a, F&gt;(f: F, s: &amp;'a str) -&gt; &amp;'a str
where
    F: Fn(&amp;'a str) -&gt; &amp;'a str,
{
    f(s)
}
<span class="boring">}</span></code></pre>
<p><strong>HRTB Variance Interaction</strong>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// HRTB with contravariance:
trait Transform {
    fn transform&lt;'a&gt;(&amp;self, input: &amp;'a str) -&gt; &amp;'a str;
}

// Implementer can use longer lifetimes in implementation:
impl Transform for Identity {
    fn transform&lt;'a&gt;(&amp;self, input: &amp;'a str) -&gt; &amp;'a str {
        input // Exact match
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="3-type-variance"><a class="header" href="#3-type-variance">3. Type Variance</a></h2>
<h3 id="covariance-of-immutable-references"><a class="header" href="#covariance-of-immutable-references">Covariance of Immutable References</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Covariant: Can pass subtype where supertype expected
fn accept_animal(a: &amp;Animal) { /* ... */ }

struct Dog;
impl Animal for Dog { /* ... */ }

let dog = Dog;
accept_animal(&amp;dog); // OK if Dog &lt;: Animal (not typical Rust, but concept)

// More realistically with lifetimes:
fn accept_static(s: &amp;'static str) { /* ... */ }
fn provide&lt;'a&gt;(s: &amp;'a str) {
    // Cannot call: &amp;'a str is NOT &lt;: &amp;'static str
    // accept_static(s); // ERROR
}
<span class="boring">}</span></code></pre>
<h3 id="invariance-of-mutable-references"><a class="header" href="#invariance-of-mutable-references">Invariance of Mutable References</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

// FAILS: Cannot pass &amp;mut String where &amp;mut Display expected
fn show(d: &amp;mut dyn Display) {
    println!("{}", d);
}

let mut s = String::from("hello");
// show(&amp;mut s); // ERROR: String is not exactly dyn Display
<span class="boring">}</span></code></pre>
<p><strong>Workaround</strong>: Use immutable reference (covariant):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn show_immut(d: &amp;dyn Display) {
    println!("{}", d);
}

show_immut(&amp;s); // OK: covariance allows trait object coercion
<span class="boring">}</span></code></pre>
<h3 id="invariance-of-cell-and-interior-mutability"><a class="header" href="#invariance-of-cell-and-interior-mutability">Invariance of &amp;Cell<t> and Interior Mutability</t></a></h3>
<pre class="playground"><code class="language-rust">use std::cell::Cell;

// Cell&lt;T&gt; is invariant to prevent aliasing unsoundness:
fn evil&lt;'a&gt;(c: &amp;Cell&lt;&amp;'a str&gt;, short: &amp;str) {
    // If Cell&lt;&amp;'a str&gt; were covariant, this would compile:
    // c.set(short); // Would store short-lived ref in long-lived cell
}

fn main() {
    let cell: Cell&lt;&amp;'static str&gt; = Cell::new("static");
    let temp = String::from("temp");
    // evil(&amp;cell, &amp;temp); // CORRECTLY REJECTED: lifetime mismatch
}</code></pre>
<h3 id="variance-rules-for-custom-generic-types"><a class="header" href="#variance-rules-for-custom-generic-types">Variance Rules for Custom Generic Types</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyBox&lt;T&gt; {
    value: T,
}
// MyBox&lt;T&gt; is COVARIANT in T (acts like T)

struct MyMutBox&lt;T&gt; {
    value: *mut T, // Raw pointer
}
// MyMutBox&lt;T&gt; is INVARIANT in T (mutable access)

struct Callback&lt;T&gt; {
    func: fn(T) -&gt; (),
}
// Callback&lt;T&gt; is CONTRAVARIANT in T (function argument)
<span class="boring">}</span></code></pre>
<p><strong>Checking Variance</strong>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Compile-time variance check:
fn assert_covariance&lt;'a, 'b, T&gt;(x: MyBox&lt;&amp;'a T&gt;) -&gt; MyBox&lt;&amp;'b T&gt;
where
    'a: 'b,
{
    x // OK if MyBox is covariant in first lifetime parameter
}
<span class="boring">}</span></code></pre>
<h3 id="when-to-declare-phantomdata"><a class="header" href="#when-to-declare-phantomdata">When to Declare PhantomData</a></h3>
<p><strong>Pattern 1: Unused Lifetime Parameters</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Iter&lt;'a, T: 'a&gt; {
    ptr: *const T,
    _marker: PhantomData&lt;&amp;'a T&gt;, // Required to declare 'a is used
}
<span class="boring">}</span></code></pre>
<p><strong>Pattern 2: Drop Check Soundness</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Guard&lt;'a, T&gt; {
    data: &amp;'a mut T,
    _marker: PhantomData&lt;T&gt;, // Ensures dropck knows we own T
}

impl&lt;'a, T&gt; Drop for Guard&lt;'a, T&gt; {
    fn drop(&amp;mut self) {
        // Can access T here safely
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="4-subtyping--lifetime-relationships"><a class="header" href="#4-subtyping--lifetime-relationships">4. Subtyping &amp; Lifetime Relationships</a></h2>
<h3 id="when-a-b-outlives-relationship"><a class="header" href="#when-a-b-outlives-relationship">When ’a: ’b (Outlives Relationship)</a></h3>
<pre><code>'a: 'b  means  'a ⊇ 'b  (a encompasses b)

Timeline:
─────────────────────────────────────►
    ├──────'a──────┤
         ├──'b──┤

'a: 'b because 'a starts before and ends after 'b
</code></pre>
<h3 id="substituting-longer-lifetimes-for-shorter"><a class="header" href="#substituting-longer-lifetimes-for-shorter">Substituting Longer Lifetimes for Shorter</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Can always pass longer lifetime where shorter expected:
fn needs_short&lt;'a&gt;(s: &amp;'a str) { /* ... */ }

let static_str: &amp;'static str = "hello";
needs_short(static_str); // OK: 'static: 'a for any 'a
<span class="boring">}</span></code></pre>
<h3 id="contravariance-in-function-arguments"><a class="header" href="#contravariance-in-function-arguments">Contravariance in Function Arguments</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// fn(T) is CONTRAVARIANT in T
type Callback&lt;T&gt; = fn(T);

// Can pass function expecting SUPERTYPE where SUBTYPE callback expected:
fn register_callback&lt;T&gt;(cb: Callback&lt;T&gt;) { /* ... */ }

fn handle_specific(s: &amp;'static str) { println!("{}", s); }
fn handle_any(s: &amp;str) { println!("{}", s); }

// This works due to contravariance:
let cb: Callback&lt;&amp;'static str&gt; = handle_any; // fn(&amp;str) &lt;: fn(&amp;'static str)
<span class="boring">}</span></code></pre>
<p><strong>ASCII Diagram: Function Contravariance</strong></p>
<pre><code>Argument Types:        &amp;'static str  &lt;:  &amp;'a str
                             │              │
Function Types:     fn(&amp;'a str)   &lt;:  fn(&amp;'static str)
                       (accepts more)    (accepts less)

Variance:              CONTRAVARIANT in argument position
</code></pre>
<h3 id="covariance-in-return-types"><a class="header" href="#covariance-in-return-types">Covariance in Return Types</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// fn() -&gt; T is COVARIANT in T
type Producer&lt;T&gt; = fn() -&gt; T;

// Can pass function returning SUBTYPE where SUPERTYPE producer expected:
fn get_static() -&gt; &amp;'static str { "hello" }

let producer: Producer&lt;&amp;'static str&gt; = get_static;
let generic_producer: Producer&lt;&amp;str&gt; = producer; // OK: covariance
<span class="boring">}</span></code></pre>
<h3 id="combining-variance-rules"><a class="header" href="#combining-variance-rules">Combining Variance Rules</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Complex example: fn(&amp;'a T) -&gt; &amp;'b U
// - Contravariant in T (argument)
// - Covariant in U (return)
// - Contravariant in 'a (argument lifetime)
// - Covariant in 'b (return lifetime)

type Transformer&lt;'a, 'b, T, U&gt; = fn(&amp;'a T) -&gt; &amp;'b U;

// Given 'long: 'short and SubT &lt;: SuperT:
// Transformer&lt;'short, 'long, SuperT, SubU&gt; &lt;: Transformer&lt;'long, 'short, SubT, SuperU&gt;
//               ↑       ↑        ↑       ↑
//            contra   cov      contra   cov
<span class="boring">}</span></code></pre>
<hr>
<h2 id="5-higher-ranked-trait-bounds-hrtbs"><a class="header" href="#5-higher-ranked-trait-bounds-hrtbs">5. Higher-Ranked Trait Bounds (HRTBs)</a></h2>
<h3 id="fora-semantics"><a class="header" href="#fora-semantics">for&lt;’a&gt; Semantics</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// HRTB: Bound must hold for ALL lifetimes
trait Parser {
    fn parse&lt;'a&gt;(&amp;self, input: &amp;'a str) -&gt; &amp;'a str;
}

// Function accepting HRTB:
fn use_parser&lt;P&gt;(parser: P)
where
    P: for&lt;'a&gt; Parser&lt;'a&gt;, // P must work for every possible 'a
{
    let s = String::from("test");
    parser.parse(&amp;s); // Works for specific 'a
}
<span class="boring">}</span></code></pre>
<h3 id="compatibility-with-variance"><a class="header" href="#compatibility-with-variance">Compatibility with Variance</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// HRTB interacts with variance:
fn map_strings&lt;F&gt;(items: Vec&lt;String&gt;, f: F) -&gt; Vec&lt;String&gt;
where
    F: for&lt;'a&gt; Fn(&amp;'a str) -&gt; &amp;'a str, // Universal quantification
{
    items.iter().map(|s| f(s).to_string()).collect()
}

// Can pass function with specific lifetime constraints:
fn identity(s: &amp;str) -&gt; &amp;str { s }
map_strings(vec![], identity); // OK: identity satisfies HRTB
<span class="boring">}</span></code></pre>
<h3 id="when-compiler-infers-hrtb-implicitly"><a class="header" href="#when-compiler-infers-hrtb-implicitly">When Compiler Infers HRTB Implicitly</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Implicit HRTB in trait objects:
let closure: Box&lt;dyn Fn(&amp;str) -&gt; &amp;str&gt; = Box::new(|s| s);
// Equivalent to: Box&lt;dyn for&lt;'a&gt; Fn(&amp;'a str) -&gt; &amp;'a str&gt;
<span class="boring">}</span></code></pre>
<h3 id="hrtb-in-closures-and-function-traits"><a class="header" href="#hrtb-in-closures-and-function-traits">HRTB in Closures and Function Traits</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Closure with HRTB inference:
let closure = |s: &amp;str| -&gt; &amp;str { s };
// Type: impl for&lt;'a&gt; Fn(&amp;'a str) -&gt; &amp;'a str

// Explicitly requiring HRTB:
fn accept_closure&lt;F&gt;(f: F)
where
    F: for&lt;'a&gt; Fn(&amp;'a str) -&gt; &amp;'a str,
{
    let temp = String::from("test");
    println!("{}", f(&amp;temp));
}
<span class="boring">}</span></code></pre>
<h3 id="hrtbs-as-workaround-for-variance-issues"><a class="header" href="#hrtbs-as-workaround-for-variance-issues">HRTBs as Workaround for Variance Issues</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Problem: Cannot abstract over specific lifetime
struct Context&lt;'a&gt; {
    data: &amp;'a str,
}

// FAILS: Cannot name all possible 'a
// fn process&lt;F&gt;(f: F)
// where
//     F: Fn(Context&lt;'a&gt;) -&gt; i32, // What is 'a here?
// { }

// Solution: HRTB abstracts over all lifetimes
fn process&lt;F&gt;(f: F)
where
    F: for&lt;'a&gt; Fn(Context&lt;'a&gt;) -&gt; i32, // Works for ANY 'a
{
    let s = String::from("data");
    let ctx = Context { data: &amp;s };
    f(ctx);
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="6-self-referential-structures"><a class="header" href="#6-self-referential-structures">6. Self-Referential Structures</a></h2>
<h3 id="why-they-require-special-handling"><a class="header" href="#why-they-require-special-handling">Why They Require Special Handling</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// FAILS: Cannot create self-referential struct safely
struct SelfRef {
    data: String,
    slice: &amp;'??? str, // What lifetime? Cannot reference self.data
}
<span class="boring">}</span></code></pre>
<p><strong>ASCII Diagram: Self-Reference Problem</strong></p>
<pre><code>Stack Memory:
┌─────────────────┐
│ SelfRef         │
├─────────────────┤
│ data: String    │ ──┐
│   ptr: *───────────►│ Heap: "hello"
│   len: 5        │   │
│   cap: 5        │   │
├─────────────────┤   │
│ slice: &amp;str     │   │
│   ptr: *────────────┘ PROBLEM: Points to data field
│   len: 5        │     (moves invalidate this!)
└─────────────────┘
</code></pre>
<h3 id="invariance-in-self-referential-types"><a class="header" href="#invariance-in-self-referential-types">Invariance in Self-Referential Types</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Even with Pin, invariance is critical:
use std::pin::Pin;

struct SelfRefPin&lt;'a&gt; {
    data: String,
    slice: &amp;'a str,
    _pin: PhantomData&lt;&amp;'a mut ()&gt;, // Invariant marker
}
<span class="boring">}</span></code></pre>
<h3 id="pinmut-self-and-self-referentiality"><a class="header" href="#pinmut-self-and-self-referentiality">Pin&lt;&amp;mut Self&gt; and Self-Referentiality</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::marker::PhantomPinned;

struct SelfReferential {
    data: String,
    ptr: *const str,
    _pin: PhantomPinned, // Prevents moving
}

impl SelfReferential {
    fn new(s: String) -&gt; Pin&lt;Box&lt;Self&gt;&gt; {
        let mut pinned = Box::pin(SelfReferential {
            data: s,
            ptr: std::ptr::null(),
            _pin: PhantomPinned,
        });

        // SAFETY: We never move this after creating the self-reference
        let ptr = unsafe {
            let self_ref: &amp;Self = &amp;*pinned;
            &amp;self_ref.data as *const String as *const str
        };

        unsafe {
            let mut_ref = Pin::as_mut(&amp;mut pinned);
            Pin::get_unchecked_mut(mut_ref).ptr = ptr;
        }

        pinned
    }
}
<span class="boring">}</span></code></pre>
<h3 id="problems-variance-creates-for-drop"><a class="header" href="#problems-variance-creates-for-drop">Problems Variance Creates for Drop</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Variance issue in drop:
struct Wrapper&lt;'a, T&gt; {
    inner: &amp;'a T,
}

impl&lt;'a, T&gt; Drop for Wrapper&lt;'a, T&gt; {
    fn drop(&amp;mut self) {
        // Can access self.inner here, but 'a might be shortened
        // println!("{}", self.inner); // Potential use-after-free!
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Solution</strong>: PhantomData enforces drop check:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SafeWrapper&lt;'a, T: 'a&gt; {
    inner: &amp;'a T,
    _marker: PhantomData&lt;&amp;'a T&gt;, // Ensures 'a lives long enough
}
<span class="boring">}</span></code></pre>
<h3 id="safe-patterns-for-self-referential-types"><a class="header" href="#safe-patterns-for-self-referential-types">Safe Patterns for Self-Referential Types</a></h3>
<p><strong>Pattern 1: Use Indices Instead of References</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Arena&lt;T&gt; {
    items: Vec&lt;T&gt;,
}

struct NodeIndex(usize);

struct Node {
    value: i32,
    children: Vec&lt;NodeIndex&gt;, // Indices, not references
}
<span class="boring">}</span></code></pre>
<p><strong>Pattern 2: Use Rc/Arc for Shared Ownership</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

struct Graph {
    nodes: Vec&lt;Rc&lt;Node&gt;&gt;,
}

struct Node {
    value: i32,
    neighbors: Vec&lt;Rc&lt;Node&gt;&gt;, // Shared ownership
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="7-common-variance-pitfalls"><a class="header" href="#7-common-variance-pitfalls">7. Common Variance Pitfalls</a></h2>
<h3 id="incorrectly-allowing-lifetime-upcasting"><a class="header" href="#incorrectly-allowing-lifetime-upcasting">Incorrectly Allowing Lifetime Upcasting</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// PITFALL: Trying to extend lifetime
fn extend_lifetime&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'static str {
    // s // ERROR: cannot return &amp;'a str as &amp;'static str
    unimplemented!()
}

// CORRECT: Only shorten lifetimes
fn shorten_lifetime&lt;'a&gt;(s: &amp;'static str) -&gt; &amp;'a str {
    s // OK: covariance allows this
}
<span class="boring">}</span></code></pre>
<h3 id="missing-invariance-on-mutable-references"><a class="header" href="#missing-invariance-on-mutable-references">Missing Invariance on Mutable References</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// PITFALL: Custom smart pointer without invariance
struct MyBox&lt;T&gt; {
    ptr: *mut T,
}

// PROBLEM: MyBox&lt;T&gt; is covariant in T by default
// Should be invariant for soundness:

struct SafeBox&lt;T&gt; {
    ptr: *mut T,
    _marker: PhantomData&lt;Cell&lt;T&gt;&gt;, // Enforces invariance
}
<span class="boring">}</span></code></pre>
<h3 id="variance-in-trait-objects"><a class="header" href="#variance-in-trait-objects">Variance in Trait Objects</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// PITFALL: Trait objects are invariant
fn accept_display(d: &amp;dyn std::fmt::Display) { /* ... */ }

fn provide_string() -&gt; &amp;String {
    &amp;String::from("hello")
}

// Cannot coerce &amp;String to &amp;dyn Display via subtyping:
// accept_display(provide_string()); // ERROR

// WORKAROUND: Explicit coercion
accept_display(&amp;*provide_string()); // OK
<span class="boring">}</span></code></pre>
<h3 id="lifetime-unsoundness-from-variance-mistakes"><a class="header" href="#lifetime-unsoundness-from-variance-mistakes">Lifetime Unsoundness from Variance Mistakes</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// CRITICAL PITFALL: Storing short-lived data in long-lived container
use std::cell::RefCell;

thread_local! {
    static STORAGE: RefCell&lt;Option&lt;&amp;'static str&gt;&gt; = RefCell::new(None);
}

fn store_temporary() {
    let temp = String::from("temporary");
    // STORAGE.with(|s| *s.borrow_mut() = Some(&amp;temp)); // ERROR: cannot infer lifetime
    // Good: Compiler prevents this unsoundness
}
<span class="boring">}</span></code></pre>
<h3 id="tools-to-detect-variance-issues-miri"><a class="header" href="#tools-to-detect-variance-issues-miri">Tools to Detect Variance Issues (Miri)</a></h3>
<pre><code class="language-bash"># Install Miri
rustup +nightly component add miri

# Run with Miri to detect undefined behavior
cargo +nightly miri test

# Miri catches:
# - Use-after-free from lifetime errors
# - Invalid variance assumptions
# - Unsafe code violating variance rules
</code></pre>
<p><strong>Example Miri Test</strong>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    #[test]
    fn test_variance_safety() {
        let mut s: &amp;'static str = "static";
        let temp = String::from("temp");
        // Attempt to violate variance:
        // s = &amp;temp; // ERROR: compiler prevents this
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="8-generic-type-variance"><a class="header" href="#8-generic-type-variance">8. Generic Type Variance</a></h2>
<h3 id="variance-in-vec-covariant-in-t"><a class="header" href="#variance-in-vec-covariant-in-t">Variance in Vec<t> (Covariant in T)</t></a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Vec&lt;T&gt; is covariant in T:
fn upcast_vec&lt;'a, 'b&gt;(v: Vec&lt;&amp;'a str&gt;) -&gt; Vec&lt;&amp;'b str&gt;
where
    'a: 'b,
{
    v // OK: Vec&lt;&amp;'a str&gt; &lt;: Vec&lt;&amp;'b str&gt;
}
<span class="boring">}</span></code></pre>
<h3 id="variance-in-t-and-mut-t"><a class="header" href="#variance-in-t-and-mut-t">Variance in &amp;T and &amp;mut T</a></h3>
<pre><code>Type               Variance in T    Variance in Lifetime
─────────────────────────────────────────────────────────
&amp;'a T              Covariant        Covariant
&amp;'a mut T          Invariant        Covariant
*const T           Covariant        N/A
*mut T             Invariant        N/A
</code></pre>
<h3 id="variance-in-function-pointers"><a class="header" href="#variance-in-function-pointers">Variance in Function Pointers</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// fn(T) -&gt; U
// - Contravariant in T
// - Covariant in U

type StringParser = fn(&amp;str) -&gt; String;
type StaticParser = fn(&amp;'static str) -&gt; String;

// Contravariance: Can pass more general where specific expected
let parser: StringParser = |s| s.to_string();
let specific: StaticParser = parser; // OK: fn(&amp;str) &lt;: fn(&amp;'static str)
<span class="boring">}</span></code></pre>
<p><strong>ASCII Diagram: Function Pointer Variance</strong></p>
<pre><code>Input Position (Contravariant):     Output Position (Covariant):
──────────────────────────────       ─────────────────────────────
&amp;'static str  ───►  &amp;str             String  ───►  String
     │                │                 │              │
fn(&amp;str)     ───►  fn(&amp;'static)    fn()-&gt;String  &lt;── fn()-&gt;String
  (supertype)       (subtype)         (identity)
</code></pre>
<h3 id="custom-type-variance-annotations"><a class="header" href="#custom-type-variance-annotations">Custom Type Variance Annotations</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker::PhantomData;

// Covariant wrapper:
struct CovariantBox&lt;T&gt; {
    value: *const T,
    _marker: PhantomData&lt;T&gt;,
}

// Invariant wrapper:
struct InvariantBox&lt;T&gt; {
    value: *mut T,
    _marker: PhantomData&lt;Cell&lt;T&gt;&gt;,
}

// Contravariant wrapper:
struct ContravariantBox&lt;T&gt; {
    callback: *const (),
    _marker: PhantomData&lt;fn(T)&gt;,
}
<span class="boring">}</span></code></pre>
<h3 id="checking-variance-with-compiler-errors"><a class="header" href="#checking-variance-with-compiler-errors">Checking Variance with Compiler Errors</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Force compiler to reveal variance:
struct Test&lt;'a, T&gt; {
    r: &amp;'a T,
}

fn check_variance&lt;'a, 'b, T&gt;(x: Test&lt;'a, &amp;'a str&gt;) -&gt; Test&lt;'b, &amp;'b str&gt;
where
    'a: 'b,
{
    x // If this compiles, Test is covariant in both 'a and T
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="9-framework-level-variance"><a class="header" href="#9-framework-level-variance">9. Framework-Level Variance</a></h2>
<h3 id="variance-in-trait-objects-and-async"><a class="header" href="#variance-in-trait-objects-and-async">Variance in Trait Objects and Async</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::future::Future;

// Trait objects are invariant:
trait AsyncHandler {
    fn handle(&amp;self) -&gt; Box&lt;dyn Future&lt;Output = ()&gt;&gt;;
}

// HRTB needed for flexible async bounds:
fn spawn_handler&lt;F, Fut&gt;(f: F)
where
    F: Fn() -&gt; Fut,
    Fut: Future&lt;Output = ()&gt; + 'static,
    F: 'static,
{
    // Can spawn f on runtime
}
<span class="boring">}</span></code></pre>
<h3 id="variance-in-higher-order-functions"><a class="header" href="#variance-in-higher-order-functions">Variance in Higher-Order Functions</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Map function with variance:
fn map&lt;'a, T, U, F&gt;(items: &amp;'a [T], f: F) -&gt; Vec&lt;U&gt;
where
    F: for&lt;'b&gt; Fn(&amp;'b T) -&gt; U, // HRTB: works for any borrow lifetime
{
    items.iter().map(f).collect()
}
<span class="boring">}</span></code></pre>
<h3 id="variance-in-callback-systems"><a class="header" href="#variance-in-callback-systems">Variance in Callback Systems</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Callback registry with proper variance:
struct Registry&lt;T&gt; {
    callbacks: Vec&lt;Box&lt;dyn Fn(&amp;T)&gt;&gt;, // Invariant in T via trait object
}

impl&lt;T&gt; Registry&lt;T&gt; {
    fn register&lt;F&gt;(&amp;mut self, f: F)
    where
        F: Fn(&amp;T) + 'static,
    {
        self.callbacks.push(Box::new(f));
    }

    fn trigger(&amp;self, value: &amp;T) {
        for cb in &amp;self.callbacks {
            cb(value);
        }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="design-patterns-that-respect-variance"><a class="header" href="#design-patterns-that-respect-variance">Design Patterns that Respect Variance</a></h3>
<p><strong>Pattern 1: Builder with Immutable References</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct QueryBuilder&lt;'a&gt; {
    filters: Vec&lt;&amp;'a str&gt;,
}

impl&lt;'a&gt; QueryBuilder&lt;'a&gt; {
    fn add_filter(mut self, filter: &amp;'a str) -&gt; Self {
        self.filters.push(filter);
        self // Covariance allows flexible lifetimes
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Pattern 2: Witness Types for Invariance</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Invariant&lt;T&gt;(PhantomData&lt;fn(T) -&gt; T&gt;); // Invariant in T

struct Container&lt;T&gt; {
    data: Vec&lt;T&gt;,
    _invariant: Invariant&lt;T&gt;, // Enforces exact type match
}
<span class="boring">}</span></code></pre>
<h3 id="breaking-variance-and-unsafe-implications"><a class="header" href="#breaking-variance-and-unsafe-implications">Breaking Variance and Unsafe Implications</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// UNSAFE: Transmuting to bypass variance
use std::mem;

fn evil_upcast&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'static str {
    unsafe {
        mem::transmute::&lt;&amp;'a str, &amp;'static str&gt;(s) // UNDEFINED BEHAVIOR
    }
}

// Calling this creates dangling reference:
// let temp = String::from("temp");
// let static_ref = evil_upcast(&amp;temp);
// drop(temp);
// println!("{}", static_ref); // USE-AFTER-FREE
<span class="boring">}</span></code></pre>
<hr>
<h2 id="10-ai-agent-checklist-for-lifetime-issues"><a class="header" href="#10-ai-agent-checklist-for-lifetime-issues">10. AI Agent Checklist for Lifetime Issues</a></h2>
<h3 id="detecting-invalid-lifetime-subtyping"><a class="header" href="#detecting-invalid-lifetime-subtyping">Detecting Invalid Lifetime Subtyping</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// RED FLAG 1: Extending lifetimes
fn suspicious&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'static str {
    s // ERROR: cannot coerce
}

// RED FLAG 2: Storing in static
static mut STORAGE: Option&lt;&amp;str&gt; = None;
fn store(s: &amp;str) {
    // unsafe { STORAGE = Some(s); } // ERROR: lifetime mismatch
}

// RED FLAG 3: Type variance bypass
fn bypass&lt;T&gt;(t: T) -&gt; T {
    unsafe { std::mem::transmute(t) } // DANGER: may violate variance
}
<span class="boring">}</span></code></pre>
<h3 id="verifying-variance-respecting-code"><a class="header" href="#verifying-variance-respecting-code">Verifying Variance-Respecting Code</a></h3>
<p><strong>Checklist</strong>:</p>
<ul>
<li>✅ Immutable references (<code>&amp;T</code>) only used in covariant positions</li>
<li>✅ Mutable references (<code>&amp;mut T</code>) treated as invariant</li>
<li>✅ Interior mutability types (<code>Cell</code>, <code>RefCell</code>) never coerced</li>
<li>✅ PhantomData used correctly for unused type parameters</li>
<li>✅ Drop implementations don’t access shortened lifetimes</li>
<li>✅ Transmute never used to bypass lifetime checks</li>
</ul>
<h3 id="patterns-that-seem-right-but-violate-variance"><a class="header" href="#patterns-that-seem-right-but-violate-variance">Patterns That Seem Right But Violate Variance</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// PATTERN 1: Storing mutable reference in collection
fn broken_collect&lt;'a&gt;(items: Vec&lt;&amp;'a mut String&gt;) -&gt; Vec&lt;&amp;'static mut String&gt; {
    // items // ERROR: cannot coerce (invariance)
    unimplemented!()
}

// PATTERN 2: Returning mutable reference to local
fn broken_return() -&gt; &amp;'static mut i32 {
    let mut x = 42;
    // &amp;mut x // ERROR: cannot return reference to local
    unimplemented!()
}

// PATTERN 3: Cell with lifetime parameter
fn broken_cell&lt;'a&gt;(c: Cell&lt;&amp;'a str&gt;) -&gt; Cell&lt;&amp;'static str&gt; {
    // c // ERROR: Cell is invariant
    unimplemented!()
}
<span class="boring">}</span></code></pre>
<h3 id="how-to-refactor-code-with-variance-issues"><a class="header" href="#how-to-refactor-code-with-variance-issues">How to Refactor Code with Variance Issues</a></h3>
<p><strong>Issue</strong>: Mutable reference prevents covariance</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BEFORE: Too restrictive
struct Container&lt;'a&gt; {
    data: &amp;'a mut String,
}

// AFTER: Split read and write capabilities
struct Container&lt;'a&gt; {
    data: &amp;'a String, // Covariant (read-only)
}

struct ContainerMut&lt;'a&gt; {
    data: &amp;'a mut String, // Invariant (write)
}
<span class="boring">}</span></code></pre>
<p><strong>Issue</strong>: Unnecessary lifetime coupling</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BEFORE: Lifetimes unnecessarily coupled
fn process&lt;'a&gt;(s: &amp;'a str, t: &amp;'a str) -&gt; &amp;'a str {
    if s.len() &gt; t.len() { s } else { t }
}

// AFTER: Independent lifetimes with bound
fn process&lt;'a, 'b&gt;(s: &amp;'a str, t: &amp;'b str) -&gt; &amp;'a str
where
    'b: 'a, // Only constrain when needed
{
    s // Return value's lifetime clear
}
<span class="boring">}</span></code></pre>
<h3 id="testing-code-that-heavily-uses-lifetimes"><a class="header" href="#testing-code-that-heavily-uses-lifetimes">Testing Code That Heavily Uses Lifetimes</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod variance_tests {
    use super::*;

    // Test 1: Verify covariance
    #[test]
    fn test_lifetime_shortening() {
        fn shorten&lt;'a, 'b&gt;(x: &amp;'a str) -&gt; &amp;'b str
        where
            'a: 'b,
        {
            x
        }

        let s: &amp;'static str = "hello";
        let _: &amp;str = shorten(s); // Should compile
    }

    // Test 2: Verify invariance rejection
    #[test]
    fn test_invariance() {
        use std::cell::Cell;

        fn cannot_shorten&lt;'a, 'b&gt;(c: Cell&lt;&amp;'a str&gt;) -&gt; Cell&lt;&amp;'b str&gt;
        where
            'a: 'b,
        {
            // c // Should NOT compile
            todo!()
        }
    }

    // Test 3: HRTB satisfaction
    #[test]
    fn test_hrtb() {
        fn identity(s: &amp;str) -&gt; &amp;str { s }

        fn accept_hrtb&lt;F&gt;(f: F)
        where
            F: for&lt;'a&gt; Fn(&amp;'a str) -&gt; &amp;'a str,
        {
        }

        accept_hrtb(identity); // Should compile
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="conclusion-variance-mastery"><a class="header" href="#conclusion-variance-mastery">Conclusion: Variance Mastery</a></h2>
<p>Variance is not optional knowledge—it’s essential for writing sound Rust code. AI agents must internalize these rules:</p>
<ol>
<li><strong>Default to covariance</strong> for immutable types</li>
<li><strong>Require invariance</strong> for mutable types and interior mutability</li>
<li><strong>Use contravariance</strong> for function arguments</li>
<li><strong>Never bypass variance</strong> with unsafe code unless proven sound</li>
<li><strong>Test variance assumptions</strong> with compile-time checks</li>
</ol>
<p><strong>Final ASCII Summary:</strong></p>
<pre><code>Variance Quick Reference:
═════════════════════════════════════════════════════════
Type                 Variance        Reason
─────────────────────────────────────────────────────────
&amp;'a T                Covariant       Safe to shorten lifetime
&amp;'a mut T            Invariant       Prevents aliasing
*const T             Covariant       Read-only pointer
*mut T               Invariant       Write capability
Box&lt;T&gt;               Covariant       Owned, like T
Vec&lt;T&gt;               Covariant       Container of T
Cell&lt;T&gt;              Invariant       Interior mutability
fn(T) -&gt; U           T: Contra       Function input
                     U: Covariant    Function output
PhantomData&lt;T&gt;       Matches T       Explicit variance
═════════════════════════════════════════════════════════
</code></pre>
<p>Master variance, and you master Rust’s type system soundness guarantees.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="14-drop-semantics-resource-management.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="16-transmute-type-punning.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="14-drop-semantics-resource-management.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="16-transmute-type-punning.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
